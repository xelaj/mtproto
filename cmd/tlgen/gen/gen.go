package gen

import (
	"bytes"
	"io/ioutil"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/xelaj/mtproto/cmd/tlgen/tlparser"
)

type Generator struct {
	schema   tlparser.Schema
	outdir   string
	replacer *strings.Replacer
	nogoify  bool
	nofmt    bool
}

func NewGenerator(schema tlparser.Schema, outdir string) *Generator {
	repl := strings.NewReplacer(
		"_", "",
		" ", "",
		".", "",
		"P2p", "P2P",
	)

	return &Generator{
		schema:   schema,
		outdir:   outdir,
		replacer: repl,
	}
}

func (g *Generator) goify(name string) string {
	if g.nogoify {
		return name
	}

	// uppercase-им первый символ
	// и все что идут после '_' или '.'
	upperc := []rune(name)
	shouldUpper := true
	for i := range upperc {
		if shouldUpper {
			upperc[i] = unicode.ToUpper(upperc[i])
			shouldUpper = false
		}

		if upperc[i] == '_' ||
			upperc[i] == '.' {
			shouldUpper = true
		}
	}

	return g.replacer.Replace(string(upperc))
}

func (g *Generator) Generate() error {

	s, err := g.createInternalSchema(g.schema)
	if err != nil {
		return err
	}

	err = g.generateFile(g.generateEnumDefinitions, s, filepath.Join(g.outdir, "enums.go"))
	if err != nil {
		return err
	}

	err = g.generateFile(g.generateSpecificStructs, s, filepath.Join(g.outdir, "types.go"))
	if err != nil {
		return err
	}

	err = g.generateFile(g.generateInterfaces, s, filepath.Join(g.outdir, "interfaces.go"))
	if err != nil {
		return err
	}

	err = g.generateFile(g.generateMethods, s, filepath.Join(g.outdir, "methods.go"))
	if err != nil {
		return err
	}

	err = g.generateFile(g.generateConstructorRouter, s, filepath.Join(g.outdir, "constructor.go"))
	if err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateFile(f func(file *jen.File, data *internalSchema) error, data *internalSchema, storeTo string) error {
	file := jen.NewFile("telegram")
	file.HeaderComment("Code generated by generate-tl-files; DO NOT EDIT.")

	//file.ImportAlias("github.com/xelaj/go-dry", "dry")

	if err := f(file, data); err != nil {
		return err
	}

	buf := bytes.NewBuffer([]byte{})

	if err := file.Render(buf); err != nil {
		return err
	}

	return ioutil.WriteFile(storeTo, buf.Bytes(), 0644)
}
