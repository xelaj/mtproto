package gen

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/xelaj/mtproto/cmd/tlgen/tlparser"
)

type Generator struct {
	schema   *internalSchema
	outdir   string
	replacer *strings.Replacer
	nogoify  bool // выключает гоферский нейминг

	// nofmt должен выключать формат кода
	// но блядский jen не поддерживает это
	// https://github.com/dave/jennifer/issues/59
	nofmt bool
}

func NewGenerator(tlschema *tlparser.Schema, outdir string) (*Generator, error) {
	internalSchema, err := createInternalSchema(tlschema)
	if err != nil {
		return nil, err
	}

	sort.Slice(internalSchema.SingleInterfaceTypes, func(i, j int) bool {
		return internalSchema.SingleInterfaceTypes[i].Name < internalSchema.SingleInterfaceTypes[j].Name
	})

	sort.Slice(internalSchema.Methods, func(i, j int) bool {
		return internalSchema.Methods[i].Name < internalSchema.Methods[j].Name
	})

	return &Generator{
		schema: internalSchema,
		outdir: outdir,
		replacer: strings.NewReplacer(
			"_", "",
			" ", "",
			".", "",
			"P2p", "P2P",
		),
	}, nil
}

func (g *Generator) goify(name string) string {
	if g.nogoify {
		return name
	}

	// uppercase-им первый символ
	// и все что идут после '_' или '.'
	upperc := []rune(name)
	shouldUpper := true
	for i := range upperc {
		if shouldUpper {
			upperc[i] = unicode.ToUpper(upperc[i])
			shouldUpper = false
		}

		if upperc[i] == '_' ||
			upperc[i] == '.' {
			shouldUpper = true
		}
	}

	return g.replacer.Replace(string(upperc))
}

func (g *Generator) Generate() error {
	err := g.generateFile(g.generateEnumDefinitions, "enums.go")
	if err != nil {
		return fmt.Errorf("generate enums: %w", err)
	}

	err = g.generateFile(g.generateSpecificStructs, "types.go")
	if err != nil {
		return fmt.Errorf("generate types: %w", err)
	}

	err = g.generateFile(g.generateInterfaces, "interfaces.go")
	if err != nil {
		return fmt.Errorf("generate interfaces: %w", err)
	}

	err = g.generateFile(g.generateMethods, "methods.go")
	if err != nil {
		return fmt.Errorf("generate methods: %w", err)
	}

	err = g.generateFile(g.generateInit, "init.go")
	if err != nil {
		return fmt.Errorf("generate init: %w", err)
	}

	return nil
}

func (g *Generator) generateFile(f func(file *jen.File), filename string) error {
	file := jen.NewFile("telegram")
	file.HeaderComment("Code generated by generate-tl-files; DO NOT EDIT.")
	f(file)

	buf := bytes.NewBuffer([]byte{})
	if err := file.Render(buf); err != nil {
		return err
	}

	dest := filepath.Join(g.outdir, filename)
	return ioutil.WriteFile(dest, buf.Bytes(), 0644)
}
