package gen

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/xelaj/mtproto/cmd/tlgen/typelang"
)

type Generator struct {
	schema *internalSchema
	outdir string
}

func NewGenerator(tlschema *typelang.Schema, outdir string) (*Generator, error) {
	internalSchema := createInternalSchema(tlschema)

	sort.Slice(internalSchema.SingleInterfaceTypes, func(i, j int) bool {
		return internalSchema.SingleInterfaceTypes[i].Name < internalSchema.SingleInterfaceTypes[j].Name
	})

	sort.Slice(internalSchema.Methods, func(i, j int) bool {
		return internalSchema.Methods[i].Name < internalSchema.Methods[j].Name
	})

	return &Generator{
		schema: internalSchema,
		outdir: outdir,
	}, nil
}

func (g *Generator) Generate() error {
	err := g.generateFile(g.generateEnumDefinitions, "enums.go")
	if err != nil {
		return fmt.Errorf("generate enums: %w", err)
	}

	err = g.generateFile(g.generateSpecificStructs, "types.go")
	if err != nil {
		return fmt.Errorf("generate types: %w", err)
	}

	err = g.generateFile(g.generateInterfaces, "interfaces.go")
	if err != nil {
		return fmt.Errorf("generate interfaces: %w", err)
	}

	err = g.generateFile(g.generateMethods, "methods.go")
	if err != nil {
		return fmt.Errorf("generate methods: %w", err)
	}

	err = g.generateFile(g.generateConstructorRouter, "constructor.go")
	if err != nil {
		return fmt.Errorf("generate constructor: %w", err)
	}

	return nil
}

func (g *Generator) generateFile(f func(file *jen.File) error, filename string) error {
	file := jen.NewFile("telegram")
	file.HeaderComment("Code generated by tlgen; DO NOT EDIT.")
	if err := f(file); err != nil {
		return err
	}

	buf := bytes.NewBuffer([]byte{})
	if err := file.Render(buf); err != nil {
		return err
	}

	dest := filepath.Join(g.outdir, filename)
	return ioutil.WriteFile(dest, buf.Bytes(), 0644) //nolint:gosec generated code is public for anyone!
}
